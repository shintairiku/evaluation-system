# 要件定義書: Server Actions Standardization and Implementation

## 1. 概要

このプロジェクトは、Next.js アプリケーションのサーバーアクション層を標準化し、すべての既存バックエンドAPIエンドポイントに対応するサーバーアクションを実装することを目的とします。現在、フロントエンドAPIレイヤーには一貫性のないパターンがあり（usersはendpoints経由、goalsは直接HTTP クライアント経由）、多くのバックエンドAPIにはフロントエンドの対応するエンドポイントファイルやサーバーアクションが不足しています。

## 2. 要件一覧

### 要件1: サーバーアクションフォーマットの標準化

**ユーザーストーリー:**
> 開発者として、統一されたサーバーアクションパターンを使用したい。なぜなら、コードの可読性と保守性を向上させ、チーム全体で一貫した開発体験を提供したいからだ。

**受入基準:**
```gherkin
WHEN 既存のサーバーアクションを確認するとき
THEN すべてのサーバーアクションが同一のパターン（endpoints経由）を使用していること

WHEN 新しいサーバーアクションを作成するとき  
THEN 標準化されたフォーマットとエラーハンドリングを使用していること

WHEN API呼び出しが失敗するとき
THEN 一貫したエラーレスポンス形式を返すこと
```

### 要件2: 欠落しているエンドポイントファイルの実装

**ユーザーストーリー:**
> 開発者として、すべてのバックエンドAPIに対応するフロントエンドエンドポイントファイルを使用したい。なぜなら、APIとの一貫した統合パターンを確立し、コードの重複を削減したいからだ。

**受入基準:**
```gherkin
WHEN バックエンドのv1 APIエンドポイントを確認するとき
THEN フロントエンドのendpointsフォルダに対応するファイルが存在すること

WHEN エンドポイントファイルを使用するとき
THEN TypeScript型安全性とAPIレスポンス形式の一貫性が保証されていること

WHEN API呼び出しエラーが発生するとき
THEN 標準化されたエラーハンドリングが提供されること
```

### 要件3: すべてのAPIエンドポイントに対するサーバーアクションの実装

**ユーザーストーリー:**
> 開発者として、すべてのバックエンドAPIに対応するサーバーアクションを使用したい。なぜなら、SSRとSEOの利点を活用し、サーバーサイドでのデータフェッチを一貫して行いたいからだ。

**受入基準:**
```gherkin
WHEN バックエンドAPIエンドポイントが存在するとき
THEN 対応するサーバーアクションが実装されていること

WHEN サーバーアクションを呼び出すとき
THEN 適切な認証とエラーハンドリングが行われること

WHEN サーバーアクションがエラーを返すとき
THEN 標準化されたエラーレスポンス形式を使用していること
```

### 要件4: Next.js キャッシュメカニズムの適用

**ユーザーストーリー:**
> 開発者として、適切なNext.jsキャッシュメカニズムを使用したい。なぜなら、アプリケーションのパフォーマンスを向上させ、サーバー負荷を削減したいからだ。

**受入基準:**
```gherkin
WHEN 読み取り専用のサーバーアクションを実行するとき
THEN 適切なRequest Memoizationが適用されていること

WHEN データの取得が繰り返される場合
THEN Data Cacheが適切に使用されていること

WHEN データが変更されるとき
THEN 関連するキャッシュが適切に再検証されること
```

### 要件5: 非機能要件 - コード品質と保守性

**要求事項:**
すべてのサーバーアクションとエンドポイントは、TypeScript型安全性、一貫したエラーハンドリング、適切なドキュメンテーションを含むこと。

**受入基準:**
```gherkin
GIVEN 新しいサーバーアクションが実装されているとき
WHEN TypeScriptコンパイルを実行するとき
THEN 型エラーが発生しないこと

GIVEN コードレビューを行うとき
WHEN エンドポイントファイルを確認するとき
THEN 適切なJSDocコメントとTypeScript型定義が含まれていること

GIVEN lintingツールを実行するとき
WHEN すべてのサーバーアクションファイルをチェックするとき
THEN lintエラーが発生しないこと
```

## 付属資料：なぜendpoints層を再度適応すべきか。
評価軸	パターンA (Endpoints層)	パターンB (直接型)
関心の分離 (SoC)	🟢 優れている<br>・Server Action: ビジネスフロー制御（キャッシュ更新、複数APIの組み合わせ等）に専念。<br>・Endpoints層: API通信の契約（URL、リクエスト/レスポンスの型）に専念。責務が明確。	🟡 劣る<br>・Server Action内にビジネスフローとAPI通信の詳細（クエリ構築等）が混在し、肥大化しやすい。
再利用性 (DRY)	🟢 優れている<br>・API通信ロジックがEndpoints層に一元化されているため、異なるServer ActionやAPI Routeから容易に再利用可能。	🔴 劣る<br>・API通信ロジックが各Server Actionに密結合しているため、類似のAPI呼び出しでもコードの重複が発生しやすい。
テスト容易性	🟢 優れている<br>・Endpoints層をモックするだけで、Server Actionのビジネスロジックを単体でテストできる。	🟡 劣る<br>・HttpClient自体をモックする必要があり、テストの準備が複雑化しやすい。
コードの見通し	🟡 やや複雑<br>・一つの処理を追うのに複数のファイル（ActionとEndpoint）を見る必要がある。	🟢 シンプル<br>・一つのActionファイル内で処理が完結するため、単純な処理は追いやすい。
スケーラビリティ	🟢 非常に高い<br>・APIが増えても、Endpoints層のおかげで構造が維持され、破綻しにくい。チームの規模が拡大しても品質を保ちやすい。	🔴 低い<br>・APIが増えるにつれて、Server Actionファイルが乱立・肥大化し、管理が困難になるリスクが高い。「技術的負債」が溜まりやすい。